section .text
    global rule1                        ; Делаем функцию rule1 видимой вне этого файла
    global rule2                        ; Делаем функцию rule2 видимой вне этого файла

rule1:
    push ebp                            ; Пролог
    mov ebp, esp                        ; функции

    mov eax, dword[ebp + 8]             ; Получаем адрес строки из стека
    xor ecx, ecx                        ; Обнуляем счётчик
    mov dl, 'a'                         ; Помещаем в регистр dl символ 'a'
    sub dl, '1'                         ; Вычитаем из регистра dl символ '1'
    .cycle:
        cmp byte[eax + ecx], 0          ; Сравниваем байт в памяти с 0
        je .out                         ; Если 0, то выходим из цикла
        cmp byte[eax + ecx], '1'        ; Сравниваем байт в памяти с символом '1'
        jb .next                        ; Если меньше '1', то переходим к следующему байту
        cmp byte[eax + ecx], '9'        ; Сравниваем байт в памяти с символом '9'
        ja .next                        ; Если больше '9', то переходим к следующему байту
        add byte[eax + ecx], dl         ; Добавляем к байту в памяти значение dl
    .next:
        inc ecx                         ; Увеличиваем счётчик
        jmp .cycle                      ; Переход к началу цикла
    .out:
        mov esp, ebp                    ; Эпилог
        pop ebp                         ; функции
        ret

rule2:
    push ebp                            ; Пролог
    mov ebp, esp                        ; функции

    mov eax, dword[ebp + 8]
    xor ecx, ecx                        ; счётчик

    .cycle1:
        cmp byte[eax + ecx], 0          ; сравниваем байт в памяти с 0
        je .out1                        ; если 0, то выходим из цикла
        cmp byte[eax + ecx], '0'        ; сравниваем байт в памяти с символом '0'
        jb .next1                       ; если меньше '0', то переходим к следующему байту
        cmp byte[eax + ecx], '9'        ; сравниваем байт в памяти с символом '9'
        ja .next1                       ; если больше '9', то переходим к следующему байту
        movzx edx, byte[eax + ecx]      ; переносим байт в регистр и расширяем его до dword
        push edx                        ; помещаем значение в стек
    .next1:
        inc ecx                         ; увеличиваем счётчик
        jmp .cycle1                     ; повторяем цикл

    .out1:
        xor ecx, ecx                    ; обнуляем счётчик

    .cycle2:
        cmp byte[eax + ecx], 0          ; сравниваем байт в памяти с 0
        je .out2                        ; если 0, то выходим из цикла
        cmp byte[eax + ecx], '0'        ; сравниваем байт в памяти с символом '0'
        jb .next2                       ; если меньше '0', то переходим к следующему байту
        cmp byte[eax + ecx], '9'        ; сравниваем байт в памяти с символом '9'
        ja .next2                       ; если больше '9', то переходим к следующему байту
        jmp .countinc                   ; если в диапазоне, то переходим к следующему байту
    .next2:                             ; если не в диапазоне, то переходим к следующему байту
        movzx edx, byte[eax + ecx]      ; переносим байт в регистр и расширяем его до dword
        push edx                        ; помещаем значение в стек
    .countinc:
        inc ecx                         ; увеличиваем счётчик
        jmp .cycle2                     ; повторяем цикл

    .out2:
        mov byte[eax + ecx], 0          ; помещаем в конец строки 0

    .ans:
        pop edx                         ; достаём значение из стека
        mov byte[eax + ecx - 1], dl     ; помещаем значение в память
        loop .ans                       ; уменьшаем счётчик и переходим в начало цикла, пока счётчик не станет равен 0

    mov esp, ebp                        ; Эпилог
    pop ebp                             ; функции
    ret